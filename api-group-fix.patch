From c6b01fa4b2c09d55fcce3183504165a49d4c0d40 Mon Sep 17 00:00:00 2001
From: Adam Krzemianowski <adam.krzemianowski@gmail.com>
Date: Sun, 19 Oct 2025 14:03:11 +0200
Subject: [PATCH] fix: Fix issue with missing api groups

---
 dist/extension.js       |  4 ++-
 out/registry/pull.js    | 80 +++++++++++++++++++++++++++++++++++++++++
 out/registry/xsUtils.js |  5 +++
 3 files changed, 88 insertions(+), 1 deletion(-)

diff --git a/dist/extension.js b/dist/extension.js
index 0d11725..b05d33d 100644
--- a/dist/extension.js
+++ b/dist/extension.js
@@ -226,7 +226,9 @@ In order to be iterable, non-array objects must have a [Symbol.iterator]() metho
 `}function l5(t,e,n,r,s,a,c){var l;if(typeof c=="function"&&(c={callback:c}),(l=c)!==null&&l!==void 0&&l.callback){var f=c,p=f.callback;$1(t,e,n,r,s,a,Vi(Vi({},c),{},{callback:function(g){g?p(t_(g)):p()}}))}else{var d=$1(t,e,n,r,s,a,c);return d?t_(d):void 0}}function M1(t,e,n,r,s,a){return l5(t,t,e,n,r,s,a)}function u5(t){var e=t.endsWith(`
 `),n=t.split(`
 `).map(function(r){return r+`
-`});return e?n.pop():n.push(n.pop().slice(0,-1)),n}var n_=class{constructor(){this.contents=new Map}updateContent(e,n){this.contents.set(e,n)}provideTextDocumentContent(e){let n=e.path;return this.contents.get(n)||""}},Ll=new n_;var Po=we(require("vscode"));var Yi=we(require("vscode"));var u_=require("path");var ms=we(require("vscode"));function d5(){return ms.languages.createDiagnosticCollection("customFunctions")}function r_(t,e,n,r,s,a){let c=new ms.Range(new ms.Position(n,r),new ms.Position(n,s)),l=new ms.Diagnostic(c,a,ms.DiagnosticSeverity.Error);t.set(e,[l])}var ya=d5();async function zr(t,e){if(e.xanoscript.status==="ok")return e.xanoscript.value;{let n=await ef(A.instanceName),r=n.startsWith("localhost")?"http":"https",s=A.workspaceId,a=`${r}://${n}/workspace/${s}-0`;return e.name?`Error retrieving: ${e.name}
+`});return e?n.pop():n.push(n.pop().slice(0,-1)),n}var n_=class{constructor(){this.contents=new Map}updateContent(e,n){this.contents.set(e,n)}provideTextDocumentContent(e){let n=e.path;return this.contents.get(n)||""}},Ll=new n_;var Po=we(require("vscode"));var Yi=we(require("vscode"));var u_=require("path");var ms=we(require("vscode"));function d5(){return ms.languages.createDiagnosticCollection("customFunctions")}function r_(t,e,n,r,s,a){let c=new ms.Range(new ms.Position(n,r),new ms.Position(n,s)),l=new ms.Diagnostic(c,a,ms.DiagnosticSeverity.Error);t.set(e,[l])}var ya=d5();async function zr(t,e){if(!e.xanoscript)return `api_group "${e.name}" {
+}
+`;if(e.xanoscript.status==="ok")return e.xanoscript.value;{let n=await ef(A.instanceName),r=n.startsWith("localhost")?"http":"https",s=A.workspaceId,a=`${r}://${n}/workspace/${s}-0`;return e.name?`Error retrieving: ${e.name}
 ---------------------------
 ${e.xanoscript.message}
  ${t} ID: ${e.id}
diff --git a/out/registry/pull.js b/out/registry/pull.js
index 1db097d..b68bb1e 100644
--- a/out/registry/pull.js
+++ b/out/registry/pull.js
@@ -497,6 +497,57 @@ function pull() {
                         console.error(`Unknown file operation ${fileOperation.operation}`);
                 }
             }
+            // Clean api_group duplicates before saving registry
+            // This prevents multiple records with the same path but different IDs (especially id=0)
+            const apiGroupsByPath = new Map();
+            const indicesToRemove = [];
+            // First pass: identify duplicates
+            for (let i = 0; i < registry.length; i++) {
+                const record = registry[i];
+                if (record.type === types_1.XanoObjectType.API_GROUP) {
+                    const existing = apiGroupsByPath.get(record.path);
+                    if (existing === undefined) {
+                        // First record for this path
+                        apiGroupsByPath.set(record.path, i);
+                    }
+                    else {
+                        // We have a duplicate
+                        const existingRecord = registry[existing];
+                        // Keep the record with valid ID (not 0)
+                        if (record.id !== 0 && existingRecord.id === 0) {
+                            // Current record is better, mark old one for removal
+                            indicesToRemove.push(existing);
+                            apiGroupsByPath.set(record.path, i);
+                        }
+                        else if (existingRecord.id !== 0 && record.id === 0) {
+                            // Existing is better, mark current for removal
+                            indicesToRemove.push(i);
+                        }
+                        else if (record.id === 0 && existingRecord.id === 0) {
+                            // Both have id=0, keep the first one (mark current for removal)
+                            indicesToRemove.push(i);
+                        }
+                        else if (existingRecord.id !== 0 && record.id !== 0 && existingRecord.id !== record.id) {
+                            // Both have different valid IDs - keep the one with higher ID (more recent)
+                            if (record.id > existingRecord.id) {
+                                indicesToRemove.push(existing);
+                                apiGroupsByPath.set(record.path, i);
+                            } else {
+                                indicesToRemove.push(i);
+                            }
+                        }
+                        // If both have the same valid ID, keep the first one
+                        else if (existingRecord.id === record.id) {
+                            indicesToRemove.push(i);
+                        }
+                    }
+                }
+            }
+            // Second pass: remove duplicates (from end to start to preserve indices)
+            const uniqueIndicesToRemove = [...new Set(indicesToRemove)].sort((a, b) => b - a);
+            for (const index of uniqueIndicesToRemove) {
+                registry.splice(index, 1);
+            }
             yield (0, registry_1.saveRegistry)(registry);
             changesTreeDataProvider_1.changesProvider.refresh();
         }))
@@ -553,6 +604,14 @@ function newRegistryRecord(fileOperations, obj, objType, path) {
         const localFilePath = (0, path_1.join)(config_1.ROOT_PATH, record.path);
         record.sha256 = (0, fsUtils_1.getFileHash)(yield (0, xsUtils_1.getXanoscriptContent)(objType, obj));
         record.original = Buffer.from(yield (0, xsUtils_1.getXanoscriptContent)(objType, obj)).toString("base64");
+        // Ensure parent directory exists before creating the file
+        const parentDir = (0, path_1.dirname)(localFilePath);
+        fileOperations.push({
+            operation: "create",
+            content: "",
+            fileType: vscode.FileType.Directory,
+            filePath: parentDir,
+        });
         fileOperations.push({
             operation: "create",
             content: yield (0, xsUtils_1.getXanoscriptContent)(objType, obj),
@@ -592,6 +651,14 @@ function updateExistingRegistryRecord(fileOperations, record, script) {
         if (record.status === types_1.XanoStatus.UNCHANGED) {
             record.sha256 = (0, fsUtils_1.getFileHash)(script);
             record.original = Buffer.from(script).toString("base64");
+            // Ensure parent directory exists before updating the file
+            const parentDir = (0, path_1.dirname)(localFilePath);
+            fileOperations.push({
+                operation: "update",
+                content: "",
+                fileType: vscode.FileType.Directory,
+                filePath: parentDir,
+            });
             fileOperations.push({
                 operation: "update",
                 content: script,
@@ -607,6 +674,14 @@ function updateExistingRegistryRecord(fileOperations, record, script) {
             if (patchedScript) {
                 record.sha256 = (0, fsUtils_1.getFileHash)(script);
                 record.original = Buffer.from(script).toString("base64");
+                // Ensure parent directory exists before updating the file (in case it was deleted)
+                const parentDir = (0, path_1.dirname)(localFilePath);
+                fileOperations.push({
+                    operation: "update",
+                    content: "",
+                    fileType: vscode.FileType.Directory,
+                    filePath: parentDir,
+                });
                 fileOperations.push({
                     operation: "update",
                     content: patchedScript,
@@ -717,6 +792,11 @@ function compareWithLocalFile(obj, registryRecord) {
     return __awaiter(this, void 0, void 0, function* () {
         const localFilePath = (0, path_1.join)(config_1.ROOT_PATH, registryRecord.path);
         const localScript = yield (0, fsUtils_1.readFile)(localFilePath);
+        // For api_group and other objects without xanoscript, compare with generated content
+        if (!obj.xanoscript) {
+            const generatedContent = yield (0, xsUtils_1.getXanoscriptContent)(registryRecord.type, obj);
+            return generatedContent === localScript;
+        }
         return obj.xanoscript.status === "ok" && obj.xanoscript.value === localScript;
     });
 }
diff --git a/out/registry/xsUtils.js b/out/registry/xsUtils.js
index 746a412..3ecb38a 100644
--- a/out/registry/xsUtils.js
+++ b/out/registry/xsUtils.js
@@ -14,6 +14,11 @@ const cache_1 = require("../metadata/cache");
 const config_1 = require("../config");
 function getXanoscriptContent(objectType, obj) {
     return __awaiter(this, void 0, void 0, function* () {
+        // API groups don't have xanoscript content - they are just containers
+        if (!obj.xanoscript) {
+            // Generate a default xanoscript for api_group
+            return `api_group "${obj.name}" {\n}\n`;
+        }
         if (obj.xanoscript.status === "ok") {
             return obj.xanoscript.value;
         }
-- 
2.50.1 (Apple Git-155)

